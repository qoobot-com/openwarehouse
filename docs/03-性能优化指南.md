# OpenWarehouse 性能优化指南

## 目录
1. 数据库优化
2. 查询优化
3. 缓存优化
4. 代码优化

---

## 一、数据库优化

### 1.1 索引优化

#### 已创建的索引
- 主键索引：所有表的主键字段
- 唯一索引：业务编码字段（如订单号、物料编码等）
- 普通索引：查询条件常用的字段
- 复合索引：多字段联合查询

#### 索引使用建议
```sql
-- 1. 查看索引使用情况
SELECT * FROM sys.schema_unused_indexes WHERE object_schema = 'openwarehouse';

-- 2. 分析查询执行计划
EXPLAIN SELECT * FROM inventory WHERE warehouse_id = 1 AND material_id = 100;

-- 3. 优化前先分析表
ANALYZE TABLE inventory;
```

### 1.2 分区表策略

对于数据量大的表（如库存变动记录表），考虑按时间分区：
```sql
-- 按月分区示例
ALTER TABLE inventory_log PARTITION BY RANGE (TO_DAYS(create_time)) (
    PARTITION p202601 VALUES LESS THAN (TO_DAYS('2026-02-01')),
    PARTITION p202602 VALUES LESS THAN (TO_DAYS('2026-03-01')),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);
```

### 1.3 查询优化

#### 分页查询优化
```java
// 优化前：深分页性能差
page(pageNum, pageSize)

// 优化后：使用ID游标分页
Page<Inventory> page = new Page<>(current, size);
QueryWrapper<Inventory> queryWrapper = new QueryWrapper<>();
queryWrapper.last("LIMIT #{size} OFFSET #{offset}");
```

#### 避免SELECT *
```java
// 优化前
mapper.selectList(null); // 查询所有字段

// 优化后：只查询需要的字段
mapper.selectList(
    new QueryWrapper<Inventory>()
        .select("id", "warehouse_id", "material_id", "quantity")
);
```

---

## 二、查询优化

### 2.1 MyBatis-Plus 优化配置

```yaml
# application.yml
mybatis-plus:
  configuration:
    # 开启二级缓存
    cache-enabled: true
    # 延迟加载
    lazy-loading-enabled: true
    # 设置查询超时时间
    default-statement-timeout: 30
```

### 2.2 批量操作优化

```java
// 优化前：循环单条插入
for (Inventory inv : list) {
    inventoryMapper.insert(inv);
}

// 优化后：批量插入
this.saveBatch(list, 500); // 每批500条
```

### 2.3 连接池优化

```yaml
spring:
  datasource:
    hikari:
      # 最大连接数
      maximum-pool-size: 20
      # 最小空闲连接
      minimum-idle: 5
      # 连接超时时间
      connection-timeout: 30000
      # 空闲连接最大存活时间
      max-lifetime: 1800000
```

---

## 三、缓存优化

### 3.1 Redis缓存配置

```java
@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}
```

### 3.2 缓存使用示例

```java
@Service
@CacheConfig(cacheNames = "inventory")
public class InventoryServiceImpl {

    @Cacheable(key = "#id")
    public Inventory getById(Long id) {
        return baseMapper.selectById(id);
    }

    @CacheEvict(key = "#inventory.id")
    public boolean updateById(Inventory inventory) {
        return baseMapper.updateById(inventory) > 0;
    }
}
```

---

## 四、代码优化

### 4.1 异步处理

```java
@Service
public class InventoryService {

    @Async
    public void updateInventoryAsync(Inventory inventory) {
        // 异步更新库存
        inventoryMapper.updateById(inventory);
    }
}
```

### 4.2 事务优化

```java
@Transactional(rollbackFor = Exception.class, timeout = 30)
public void processInbound(InboundOrder order) {
    // 业务逻辑
}
```

### 4.3 避免N+1查询问题

```java
// 优化前：N+1查询
List<InboundOrder> orders = orderMapper.selectList(null);
for (InboundOrder order : orders) {
    List<InboundOrderDetail> details = detailMapper.selectList(
        new QueryWrapper<InboundOrderDetail>().eq("order_id", order.getId())
    );
}

// 优化后：使用JOIN或批量查询
List<InboundOrder> orders = orderMapper.selectListWithDetails();
```

---

## 五、监控与调优

### 5.1 慢查询监控

```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2; -- 超过2秒的查询记录

-- 查看慢查询
SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10;
```

---

## 六、优化检查清单

- [ ] 所有查询字段都有适当的索引
- [ ] 避免使用SELECT *，只查询需要的字段
- [ ] 分页查询使用ID游标方式
- [ ] 批量操作使用saveBatch方法
- [ ] 热点数据使用Redis缓存
- [ ] 耗时操作使用异步处理
- [ ] 定期分析慢查询日志
- [ ] 监控数据库连接池状态
- [ ] 大表考虑分区策略
- [ ] 定期执行ANALYZE TABLE优化表统计信息

---

**更新时间**: 2026-02-15
